### 执行一条Select 语句，期间发生了什么

```mysql
select * from product where id = 1;
```



#### MySQL执行流程是怎么样的?



![mysql查询流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

可以看出来，MySQL的架构一共分成两层: Server层和存储引擎层

* Server层负责建立连接，分析和执行SQL。

  很多主要功能都在这里实现包含

  连接器，查询缓存，解析器，预处理器，优化器，执行器等。另外，所有的内置函数（如日期，时间，数字和加密函数等）和所有跨存引擎的功能（如存储过程，触发器，试图等）

  都在Server层实现

* <font color="blue">存储引擎层负责数据的存储和提取</font> 支持InnoDB、MyISAM、Memory等多个存储引擎，不同的存储引擎公用一个Server层，现在最常用的存储引擎是InnoDB，从MySQL5.5开始，InnoDB成为了MySQL的默认存储引擎。 常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同。比如InnoDB支持索引类型是B+树，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是B+树索引。



### 第一步：连接器

在操作系统中连接MySQL，第一步是要链接MySQL服务,然后才能执行SQL语句

```mysql
# -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；
# -u 指定用户名，管理员角色名为 root；
# -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码
mysql -h$ip -u$user -p
```

连接的过程需要先进行TCP三次握手，因为MySQL是基于TCP协议进行传输的。

如果用户密码都没有任何问题。连接器就会获取该用户的权限，然后保存起来，后续该用户在此链接里的任何操作，都会基于开始时读到的权限进行权限逻辑的判断。

（所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。）



> 如何查看MySQL服务被多少个客户端连接了？

Show processlist 

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5.png)

如上图所示，共有两个用户名为root用户连接了MySQL服务，其中id为6的用户的Command列为` Sleep` 这意味着该用户连接完MySQL服务就没有再执行过任何命令，就是一个空闲的连接，并且空闲的时长是736秒（Time列）

> 空闲链接会一直占用着吗？

MySQL通过` wait_timeout`定义了空闲连接的最大空闲时长，默认是8小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。

> MySQL的连接数有限制吗？

MySQL通过` max_connection`参数控制。

##### MySQL的连接也跟HTTP一样，有短连接和长连接的概念。

```
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

可以看到，长连接的好处就是可以减少建立的连接和断开连接的过程，一般推荐使用长连接。

但是长连接后可能会产生内存增多，因为MySQL在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。

> 如何解决长连接占用内存的问题

第一种： <font color="blue">定期断开长连接</font> 既然断开连接后就会释放连接占用的内存资源，那就可以定期断开长连接

第二种：<font color="blue">客户端主动重置连接</font>.MySQL 5.7版本实现了 ` mysql_reset_connection()`函数的接口。

需要注意的是：这是函数接口，不是命令，那么当客户端执行了一个很大的操作后，在代码里调用mysql_reset_connection函数来重置连接，达到释放内存的效果，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

**以上是连接器的工作，总结一下**

* 与客户端进行TCP三次握手连接；
* 校验客户端的用户名和密码。
* 如果全部正确，则会读取用户的权限，然后后续的权限逻辑判断都基于此时读取的权限。（缓存下来； ）